The idea behind entmesh: To allow entropy to move from where it's abundant to
where it's needed within a network of computers.

Terms:
* HRNG: Hardware Random Number Generator. Used somewhat interchangeably with
  TRNG in this document.
* TRNG: True Random Number Generator. Used somewhat interchangeably with HRNG
  in this document.
* Node: The base logical device in the connection graph.
* Tank: A Node where entropy is stored. Examples include the kernel entropy
  pool, as well as userland buffers.
* Fill Level: How full a Tank is.
* Source: A Node where entropy is generated.
* Examples include the kernel's own attempts at generating entropy, as well as
  hardware TRNGs, haveged, etc.
  This is abstracted as a Tank which is always full.
* Connection: A bidirectional data path between two Nodes. Connections are
  initialized, utilized and terminated, in that order. Connections carry all
  explicit messages, including Fill Level Notifications and Entropy Transfers.
* Peer: A Node connected to this Node.

Peer relationships:
* When two Nodes are connected to each other, they have a relationship as
  Peers.
* Each Node in a Peer relationship may choose whether or not it will send or
  receive data from its Peer. This has a logical basis in that an HRNG cannot
  receive data, and it has a security basis in that we may not trust the
  quality of entropy from a Peer, even though we may wish to provide it with
  entropy.
* Peers may notify each other about their current entropy level. Such
  notifications carry implicit flow control requests; if a Node notifies its
  Peer that it's starving for entropy, it's implicitly requesting that its
  Peer send it entropy.

Events:
* Fill Level Notificaton: When a Node informs its Peer of its current Fill
  Level.
* Entropy Transfer Request: When a Node requests that its Peer send it
  entropy. This event is detected by the receiving Node of a Fill Level
  Notification, determined by comparing the receiver's Fill Level with the
  that received.
* Entropy Transfer: When one Node sends entropy to another Node.

Fill Levels:

For two Connected Nodes, A and B, with each other as Peers:

* If Node A's Fill Level is the same as Node B's Fill Level, then there is no
  Entropy Transfer Request.
* If Node A's Fill Level is Significantly higher than Node B's Fill Level,
  then Node B has implicitly sent an Entropy Transfer Request to Node A.
* If Node B's Fill Level is Significantly higher than Node A's Fill Level,
  then Node A has implicitly sent an Entropy Transfer Request to Node B.

How a Fill Level Notification is sent between Nodes is an implementation
detail of the Connection between Nodes. Example communication means include
percentages, fractions and enumerated states (i.e. GOOD, OK, LOW, CRITICAL).

It is an error for a Node to transmit the same Fill Level Notification
consecutively on the same Connection. If Node A knows Node B is at Fill Level
S, then if Node A receives a Fill Level Notification from B indicating B is at
Fill Level S, then A has clearly received a duplicate notification, and the
connection should be terminated.

Entropy Transfers:

When an Entropy Transfer occurs, one Tank removes entropy from itself and
sends it across its Connection to another Tank, which MAY add that entropy to
itself. The sending Tank SHOULD continue sending entropy until there is no
longer an outstanding Entropy Transfer Request. The sending Tank MUST
NOT send the same entropy more than once to the same Node, and the sending Tank
MUST NOT send the same entropy to more than one Node. It is recognized and
accepted that entropy may be lost, discarded or wasted as a consequence.

Entropy Transfer Requests:

Entropy Transfer Requests are virtual in nature, meaning they are not sent
explicitly. Instead, they are detected by the Node receiving the Fill Level
Notification by comparing the announced Fill Level with the receiving Node's
own Fill Level, and determining if they are Significantly different. This
determination is implementation-defined. Entropy Transfer Requests can only be
terminated by the this same Node's determining that the two Node's Fill Levels
are no longer Significantly different.

A Node which receives an Entropy Transfer Request SHOULD initiate an Entropy
Transfer in response.

Examples:

K = Kernel entropy pool, abstracted as a Tank Node.
M = Memory FIFO entropy buffer, abstracted as a Tank Node.

Single-host, no external entropy source:
K<->M
* K Trusts M
* M Trusts K

In this example, some internal abstraction driver describes the kernel entropy
pool as a Tank, monitors its level, handles Fill Level announcements and
Entropy Transfers. Since the kernel entropy pool only stores a very, very
small amount of entropy (512 bytes), having a separate M Tank can be
beneficial; it allows us to save off any excess entropy generated or received
that wouldn't otherwise have fit in K. When K runs low, entropy is moved from
M back into K.

Two hosts, equally trusted:

K1 <-> M1 <-> M2 <-> K2

* K1 and M1 are on the same host
* K1 and M1 trust each other.
* K2 and M2 are on the same host
* K2 and M2 trust each other.
* M1 and M2 trust each other.

In this example, the Linux kernel for host 1 will attempt to fill K1, and the
kernel for host 2 will likewise fill K2. K1 and M1 will attempt to keep each
other filled, K2 and M2 will attempt to keep each other filled, and M1 and M2
will attempt to keep each other filled.

So, if K2 runs dry, draining M2, then M1 will feed into M2, which will feed
into K2. If M1 runs dry, K1 will attempt to fill it.

Likewise, if K1 runs dry, draining M1, then M2 will feed into M1, and K2 will
feed into M2.

In this way, entropy will flow from where it's available to where it's needed.

Two hosts, unequal trust:
Let's say that in the situation above, host 1 does not trust the quality of
entropy from host 2, but does want to keep host 2 supplied with entropy.
(Perhaps host 1 has an HRNG tied into K1)

K1 <-> M1 -> M2 <-> K2

If M1 sends K1 a Fill Level announcement, and K1 sees that M1 has a lower Fill
Level than K1 has, K1 will initiate an Entropy Transfer to try to fill M1.

Client/Server entropy cluster:

K1 <-> M1 <--v
K2 <-> M2 <->M3-,
                +------->M4<->K4
                +------->M5<->K5
                +------->M6<->K6
                +------->M7<->K7
                 \------>M8<->K8

Here, you have two hosts, 1 and 2, sharing trust with buffer M3. M4-M8 aren't
trusted by anyone but their hosts' kernels, and it's M3's job to keep them
supplied with entropy.

(This is how I see entmesh being useful in VM cluster environments.)

